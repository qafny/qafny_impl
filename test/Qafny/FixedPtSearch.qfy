method FixedPtSearch(q : Q[1], p: Q[n], r:Q[1], n:nat, f : [Bool] -> Bool, N: nat) returns (y:nat, p : real, x:nat, prob:real)
  requires m < 2^n
  requires forall k :: 0 <= k < m ==> f(n2b(k)) == 1
  requires forlal k :: m <= k < m ==> f(n2b(k)) == 0
  requires { q[0] : nor ↦ |0⟩ }
  requires { p[0 , n) : nor ↦ |0⟩ }
  requires { r[0] : nor ↦ |0⟩ }
  ensures y == 1 ==> p == ... //need to put the probablity
{
  q[0] *= H;
  p[0,n) *= H;
  
  assert {q[0] : en ↦ 1 / sqrt(2) (|0⟩ + |1⟩)}
  assert { p[0,n) : en ↦ part(2^n, sin theta : f(|k⟩) == 1, cos theta : f(|k⟩) == 0) } 

  for i in [0, N)
    invariant {
      q[0 .. n] : en ↦ part(2^n, sin (2 * i * theta + theta) : f(|k⟩) == 1, cos (2 * i * theta + theta) : f(|k⟩) == 0)
    }
  {

    if p[0] { q[0,n),r[0] *= λ (y:Q n, z: Q 1 => f(y,z)); }
    y,p := measure(r[0]);
    if (y == 1){
      break;
    }
    p[0],q[0, n) *= amp; //this amplitude value will increase the amplitude of f(k) == 1 group while describing the amplitude of f(k) == 0 group.

  }
  x,prob := measure(q);
}

