method Simon(q : Q[n], p : Q[n], n:nat, f : nat -> nat, s : nat) returns (y:nat, p : real)
  requires forall k :: 0 <= k < 2^(n-1) ==> f(b2n(k)) == f(s xor (k+2^(n-1)))
  requires s != 0
  requires { q[0 , n) : nor ↦ |0⟩ }
  requires { p[0 , n) : nor ↦ |0⟩ }
  ensures y == 1 ==>  p == 0
  ensures y == 0 ==> p == 1 / 2^(n-1)
{
  q[0, n) *= H; 
  
  for i in [0, n) with q[i]
    invariant {
      q[0, i), p[0, n) : en ↦ ∑ k ∈ [0, 2^i) . 1 / sqrt(2^n) . | k , ∑ j ∈ [0, i) . f(n2b(k))[j] ⟩
    }
    invariant {
      q [i , n) : had ↦ |+⟩
                           
    }
  {
    if (q[i]) { p[0, n) *= λ (y => |(y + f(x))⟩); }
  }

  q[0,n) *= H; 
  assert { q[0,n),p[0,n) : en ↦ ∑ y ∈ [0, 2^n) . 1 / sqrt(2^n) * 1 / sqrt(2^n) . ∑ k ∈ [0, 2^n) . ω (k . y, 2) . |y⟩ |f(k)⟩ };
  y,p *= measure(q, 0);
}  

