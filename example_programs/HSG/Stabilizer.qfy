// Abelian Stabilizer problem / Kitaev's algorithm
// https://arxiv.org/pdf/quant-ph/9511026.pdf

// Can I assume q comes with phi stored on it already?
// What to do if the algorithm fails to produce H?

method Stabilizer (q : Q[n], k:nat, n:nat, a:nat, F : nat -> nat -> nat, h:[nat], m:[nat]) returns (h:[nat])
    //requires q : Nor -> |psi> - how do I express that q has value of psi as a condition?
    requires a < 2^n //is array<bv1> the correct data type for a?
    requires forall k :: 0 <= k < |m| ==> F(0, m[k]) == m[k] //for any element x of M, F(0,x)==x
    requires forall k :: 0 <= k < |m| ==> 
        forall i :: 0 <= i < 2^n ==>
        forall j :: 0 <= j < 2^n ==>
        F(i + j, m[k]) == F(i, F(j, m[k]))
    //postcondition: for all elements of h, F(h,a) == a
    ensures forall k :: 0 <= k < |h| ==> F(h[k], a) == a
{
    h := [];
    i := 0;
    while i < O(k * n * log(k * n)) // repeat measurement O(knlog(kn)) times
        invariant 0 <= i <= O(k * n * log(k * n))
        invariant |h| == i
        invariant forall k :: 0 <= k < |h| ==> F(h[k], a) == a
    {
        q' := q; // way to reset value over multiple iterations?

        q'[0,n) *= H;

        y, p *= measure(q'[0,n));
        // y is an element of H
        assert y âˆˆ h;
        assert F(y, a) == a;

        h := h + [y]; // perhaps h := h \/ y is better

        i := i + 1;

    }

    // check if h is correct

    //if h == h
   // {
   //     return h;
   // }
    // what if it isn't? try again until it succeeds (prove termination?) or just return as a failure?
   // return [ ];
}
