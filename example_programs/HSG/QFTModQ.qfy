// QFT mod Q
// https://people.eecs.berkeley.edu/~vazirani/s09quantum/notes/lecture6.pdf
// Section 0.3
//the document contains bugs. The controlled-shift is not clear, and the eigenvalue state is not explained properly.

method rzSeq(q:Q[n],n:nat, a:nat) 
  requires {q[0 , n) : Nor ↦ |a⟩}
  ensures {q[0,i) : Nor ↦ ω (a, 2^n) |a⟩}
{
  for i in [0,n)
  invariant {q[0,i) : Nor ↦ ω (a[0,i), 2^n) |a⟩} //we need to create a[0,i) means sum_i 2^0*a[0]+ ...+ 2^i * a[i]
  {
    q[i] *= λ((x:Q[1]) ==> ω (2^i * x[i], 2^n) x)
  }
}

//we will use the inversed of the function
method QPEQ(q : Q[n], p : Q[n], n:nat, a: nat, Q:nat)
  requires { q[0 , n) : Nor ↦ |0⟩ }
  requires { p[0 , n) : En ↦ ∑ k ∈ [0, 2^n)) . 1 / sqrt(2^n) . ω (k * a, 2^n) | k ⟩ }
  ensures { q[0, i), p[0, n) : En ↦ ∑ d ∈ [0, 2^n)) . ∑ k ∈ [0, 2^n)) . 1 / 2^n * 1 / sqrt(2^n) . ω (k * a + c * a - c * d, 2^n) | d , k ⟩ }
{
  q[0, n) *= H;

  for i in [0, n) with q[i]
    separates q[0, n), p[0, n)
    invariant {
      q[0, i), p[0, n) : En ↦ ∑ c ∈ [0, 2^i)) . ∑ k ∈ [0, 2^n)) . 1 / sqrt(2^i) * 1 / sqrt(2^n) . ω (k * a + c * a, 2^n) | c , k ⟩
    }
   invariant {//is this necessary, before the loop, q is in Had, so q[k,n) in Had is well-known.
      q [k , n) : Had ↦ |+⟩
    }
  {
    //need an axiom to say that ω (v * a, 2^n) (|k> -> |k + 2^j mod Q>) actually turns   ω (v * a, 2^n) to be ω (v * a - 2^j * a, 2^n)
    p[0, n) *= λ ((y:Q[n]) => y + 2^i mod Q);
  }
  
  q[0,n) *= RQFT;
      
}


//the following proof might be bad, a better way to do the proof is to first apply the QPE on the eigen value function 
//ω (v * a, 2^n) (|k> -> |k + 2^j mod Q>) actually turns   ω (v * a, 2^n) to be ω (v * a - 2^j * a, 2^n), without the final measurement
//Then, the steps from 39 to 55 are just the inversed QPE. In quantum, if a unitary is given, we can have the axiom,
//where the inversed function f^-1 takes the output of the original function f and it produces the input.
method QFTModQ(q : Q[n], p : Q[n], n:nat, a: nat, Q:nat)
  requires forall k :: 0 <= k < 2^(n-1) ==> f(n2b(k)) == f(s xor n2b(k+2^n))
  requires b2n(s) != 0
    // we can assume that all elements in the function are lined up with, without losing generality, since we do not rely on the structure
  requires { q[0 , n) : Nor ↦ |a⟩ }
  requires { p[0 , n) : Nor ↦ |0⟩ }
  //we should have a way of only specifying basis.
  //but we also care about amplitudes here.
  //ensures n2b(y) . s == 0 ==>  p == 0
  //ensures n2b(y) . s == 1 ==> p == 1 / 2^(n-1)
  ensures { q[0 , n) : Nor ↦ |0⟩ }
  ensures { p[0 , n) : En ↦ ∑ k ∈ [0, 2^n)) . 1 / sqrt(2^n) . ω (k * a, 2^n) | k ⟩ }
{
  p[0, n) *= H;
  
  for i in [0,n) && p[i]
  invariant {q[0, i), p[0, n) :  En ↦ ∑ k ∈ [0, 2^i)) . 1 / sqrt(2^i) . ω (k * a, 2^n) | a , k ⟩  }
  {
    rzSeq(q, n, a)
  }

  QPEQ^{-1}(q,p,n,a,Q); //since we use the inversed of the function, so the output becomes the input, and d = a
                        //then, we get the input as in QPEQ as the output.
  
  assert {q[0, n), p[0, n) : En ↦ ∑ c ∈ [0, 2^n)) . ∑ k ∈ [0, 2^n)) . 1 / sqrt(2^n) . ω (k * a, 2^n) | c , k ⟩}
  assert {q[0, n) : En ↦ ∑ c ∈ [0, 2^n)) . | c ⟩ ⊗ p[0, n) : En ↦ ∑ k ∈ [0, 2^n)) . 1 / sqrt(2^n) . ω (k * a, 2^n) | k ⟩}

  q[0, n) *= H;

}
