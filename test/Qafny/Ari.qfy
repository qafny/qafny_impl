// --------------------------- LOGIC GATES -------------------------------------


// Works.
method HadamardZero(q : Q[1]) returns (q : Q[1])
  requires {q[0] : nor ↦ |0⟩}
  ensures {q[0] : had ↦ |+⟩}
{
  q[0] *= H;
}

// Doesn't compile
method HadamardGeneral(q : Q[1], a : real, b : real) returns (q : Q[1])
  requires {q[0] : had ↦ a|0⟩ + b|1⟩}
  ensures {q[0] : had ↦ (a+b)/sqrt(2)|0⟩ + (a-b)/sqrt(2)|1⟩}
{
  q[0] *= H;
}

// Compiles, doesn't verify, since "castBVInt(q6)" generates instead of "castBVInt(q7)"
method PauliX(q : Q[1]) returns (q : Q[1])
  requires {q[0] : nor ↦ |0⟩}
  ensures {q[0] : nor ↦ |1⟩}
{
  q[0] *= λ (x => |(x + 1) % 2⟩);   // Not general - only works for nor types.
}


method PauliXGeneral(q : Q[1], x : nat) returns (q : Q[1])
  requires {q[0] : nor ↦ |x⟩}
  ensures {q[0] : had ↦ i|1⟩}
{
  // Want: a|0> + b|1> maps to a|1> + b|0>.
  // Is this possible?
}


// ---------------------- STATE CONSTRUCTION -----------------------------------

method BellPair(q : Q[2]) returns (q : Q[2])
  requires {q[0,2) : nor ↦ |00⟩}
  ensures {q[0,2) : en ↦ ∑ k ∈ [0, 2) . 1/sqrt(2) |kk⟩}
  ensures {q[0,2) : en ↦ 1/sqrt(2) (|00⟩) + 1/sqrt(2) (|11⟩)}

  // These versions of the above line don't work:
  // ensures {q[0,2) : en ↦ 1/sqrt(2) ∑ k ∈ [0, 2) . |kk⟩}
  // ensures {q[0,2) : en ↦ 1/sqrt(2) (|00⟩ + |11⟩)}
  // It appears Qafny doesn't like statements with magnitudes factored out

{
  q[0] *= H;
  if (q[0]) { q[1] *= λ (x => |(x + 1) % 2⟩); }
}


method GHZ(q : Q[3]) returns (q : Q[3])
  requires {q[0,3) : nor ↦ |000⟩}
  ensures {q[0,3) : en ↦ ∑ k ∈ [0, 2) . 1/sqrt(2) |k⟩|k⟩|k⟩}
{
  q[0] *= H;
  if (q[0]) {
    q[1] *= λ (x => |(x + 1) % 2⟩);
    q[2] *= λ (x => |(x + 1) % 2⟩);
  }
}

//method GHZGeneral(q : Q[n]) returns (q : Q[n])
//  requires {q[0,n) : nor ↦ ⊗ i ∈ [0,n) . |0⟩}
//  ensures {q[0,n) : en ↦ ∑ k ∈ [0, 2) . 1/sqrt(2) ((⊗ i ∈ [0,n) . |k⟩)}
//{
  //q[0] *= H;
  //for i in [0, n) {
   // if (q[0]) {
    //  q[i] *= λ (x => |(x + 1) % 2⟩);
    //}
  //}
//}



// ------------------------- REVERSIBILITY -------------------------------------

// Apply the hadamard gate twice to return to the inital state
method DoubleH(q : Q[1]) returns (q : Q[1])
  requires {q[0] : nor ↦ |0⟩}
  ensures {q[0] : nor ↦ |0⟩}
{
  q[0] *= H;
  q[0] *= H;
}

// Reverse a QFT


// -------------------- QUANTUM FOURIER TRANSFORM ------------------------------


// Do a QFT on 

// Apply one, check if it's as described in the paper






// Notes:
// - Omega(x,y) is the xth root of unity for root y, ie, omega(x,y)=exp(2πix/y)
