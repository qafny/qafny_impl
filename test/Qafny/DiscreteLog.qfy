method DLog(q : Q[n], p : Q[n], t : Q[n], n:nat, N : nat, x : nat, g:nat, r:nat, c:nat) returns (u:nat, v:nat, p : real)
  requires 1 < x < N <= 2^n
  requires 1 < g < N <= 2^n //if we do not want allow this syntax, fine.
  requires gcd(x,N) == 1
  requires gcd(g,N) == 1
  requires { q[0 , n) : nor ↦ |0⟩ }
  requires { p[0 , n) : nor ↦ |0⟩ }
  requires { t[0 , n) : nor ↦ |0⟩ }

  ensures u == v * log(g, x)
  ensures v == log(g, x)
  ensures p == Omega(1 / log(log(N)))
{
  q[0, n) *= H;
  p[0, n) *= H;
  t[0, n) *= λ (x => |x + 1⟩);
  
  for i in [0, n)
    invariant {
      q[0, i), t[0, n) : en ↦ ∑ k ∈ [0, 2^i) . 1/sqrt(2^i) | k ⟩ | (x ^ k) % N ⟩
    }
    invariant {
      q [i , n) : had ↦ |+⟩
    }
  {
    if (q[i]) { t[0, n) *= λ (a => | ((x ^ (2^i)) * a) % N ⟩ ); }
  }

  for i in [0, n)
    invariant {
      q[0, n),p[0, i) t[0, n) : en(2) ↦ ∑ k ∈ [0, 2^i) . ∑ j ∈ [0, 2^n) . 1/sqrt(2^i) * 1/sqrt(2^n)  | k ⟩ | j ⟩ | (g ^ j) * (x ^ k) % N ⟩
    }
    invariant {
      p [i , n) : had ↦ |+⟩
    }
  {
    if (q[i]) { t[0, n) *= λ (a => | ((g ^ (2^i)) * a) % N ⟩ ); }
  }

  v,prob *= measure(t[0,N));//we will then measure t, please see andrew's note, to see what is the result assertion
  delta := log(g,v);
  q[0,n),p[0,n) *= RQFT;

  assert { q[0, n), p[0, n) : en ↦ ∑ k ∈ [0, 2^i) .  1 / sqrt(N) * omega(k, delta, N) | k * log(g, x)  ⟩ | k ⟩}; 
  u,v,p *= measure(q[0,n),p[0,n));
  
}  

