import Programmer
from LocusCollector import LocusCollector
from Programmer import *
from ProgramVisitor import ProgramVisitor
from SubstAExp import SubstAExp
from SubstDAExp import SubstDAExp
from TargetProgrammer import *
from CollectKind import *
from TypeChecker import TypeChecker, subLocusGen


def compareQRange(q1: QXQRange, q2: QXQRange):
    return (str(q1.ID()) == str(q2.ID())
            and compareAExp(q1.crange().left(),q2.crange().left())
            and compareAExp(q1.crange().right(),q2.crange().right()))

def compareRangeLocus(q1: QXQRange, qs: [QXQRange]):
    vs = []
    for i in range(len(qs)):
        if compareQRange(q1,qs[i]):
            return (vs + (qs[i+1:len(qs)]))
        vs = vs + [qs[i]]
    return None

def compareLocus(q1: [QXQRange], q2: [QXQRange]):
    vs = q2
    for elem in q1:
        vs = compareRangeLocus(elem, vs)
        if vs is None:
            return None

    return vs

def subLocus(q2: [QXQRange], qs: [([QXQRange], QXQTy, int)]):
    vs = q2
    qsf = []
    for locus,qty,num in qs:
        vs = compareLocus(q2, locus)
        if vs is not None:
            return locus,qty, num
    return None

def genType(n:int, t:DXType):
    for i in range(n):
        t = SeqType(t)
    return t

def makeVars(locus:[QXQRange], t:QXQTy, n:int):
    tmp = []
    if isinstance(t, TyNor):
        for elem in locus:
            tmp += [DXBind(elem.ID(), SeqType(SType("bv1")),n)]

    elif isinstance(t, TyEn):
        num = t.flag().num()
        tmp += [DXBind("amp", genType(num, SType("real")), n)]
        tmp += [DXBind("phase", genType(num, SType("real")), n)]
        for elem in locus:
            tmp += [DXBind(elem.ID(), genType(num, SeqType(SType("bv1"))),n)]
    
    elif isinstance(t, TyHad):
        for elem in locus:
            tmp += [DXBind(elem.ID(), SeqType(SType("real")), n)]

    return tmp

def makeMap(ids: [str], locus: [QXQRange]):
    tmp = dict()
    for i in range(len(ids)):
        tmp.update({ids[i]:locus[i]})
    return tmp

def makeIndex(id : DXBind, sums: [QXCon]):
    tmp = id
    for elem in sums:
        tmp = DXIndex(tmp, DXBind(elem.ID(),SType("nat")))
    return tmp

def locateAExp(locus: [QXQRange], r:QXQRange, lexp:[DXAExp]):
    for i in range(len(locus)):
        if compareQRange(locus[i], r):
            return lexp[i]
    return None

def replaceAExp(locus: [QXQRange], r:QXQRange, lexp:[DXAExp], rep: DXAExp):
    re = []
    for i in range(len(locus)):
        if compareQRange(locus[i], r):
            re += [rep] + lexp[i+1:]
            return re
        else:
            re += lexp[i]
    return lexp

def updateInd(lexp:[DXAExp], ind: DXAExp):
    tmp = []
    for elem in lexp:
        tmp += [DXIndex(elem,ind)]
    return tmp


# In the transfer below. transferring a stmt/exp results in a list of resulting stmts in Dafny
# but transferring logic specification results in one specification
class ProgramTransfer(ProgramVisitor):

    def __init__(self, kenv: dict, tenv: dict):
        # need st --> state we are deling with
        # kind env, can be generated by CollectKind.
        # mapping from function names to mappings.
        # each mapping is a map from variables to kinds in a method.
        # different methods have different mapping
        self.kenv = kenv
        # type env, can be generated by TypeCollector
        # mapping from function names to two lists of pairs.
        # each list contains pairs of a locus and a type
        # meaning that the locus has a certain type
        # different loci in a list are disjoint
        # there are two lists for each function name
        # The first list contains the type information for the loci at the input
        # The second list contains the type information for the loci at the output location
        self.tenv = tenv
        # fkenv a kind env in a function.
        # in visitMethod, we find out the kind-env for the fun-name.
        self.fkenv = None
        #ftenvp gets the locus-list at the input position of a function
        self.ftenvp = None
        # ftenvp gets the locus-list at the output position of a function
        self.ftenvr = None
        #varnums is the locus-list at the input position
        #There is an additional field for each pair (like now it is not a pair, but triple)
        #The third field iin a triple is a generated identifier (a number) to identify the specific locus
        self.varnums = None
        #The sizemap is for used inside a function
        #This sizemap maps a range in a locus to its size
        #like x[i,j) has the size j - i
        self.sizemap = dict()
        #The counter generates a new identifier for a locus,
        #When generating a locus ID, we increment the counter
        self.counter = 0
        #The function name when visiting a method
        self.fvar = ""
        #For a locus in a spec, we generate Dafny variables for each range in a locus,
        #depending on the types
        #For example, if x[i,j) , y[0,n) |-> en(1).
        #In Qafny, the variables x and y have no extra number identifier, because it is unnecessary
        #In Dafny, each instruction/function call will generate new seq variables
        #So, we need to always generate different new instances for x and y
        #So, for a spec, we will call the counter to generate the new identifier
        #and the Dafny variable for the locus is DVar(x,counter), DVar(y,counter),
        # DVar(amp,counter), and DVar(phase,counter)
        # The variables are also associated with types, and depend on types
        #Now, the DVars above have type seq<real> or seq<seq<bv1>>
        # if we have a en(2) type above, we will have seq<seq<real>> and seq<seq<seq<bv1>>>
        self.qvars = []
        #When analyzing a locus in a specific plance
        #We assign the locus to the global field in the visitor class
        #This will reserves the locus and allow the sub-visitor-call to assign the current locus
        self.locus = []

    def genVarNumMap(self, tenv: [([QXQRange], QXQTy)]):
        tmp = []
        for locus, qty in tenv:
            tmp = tmp + [(locus, qty, self.counter)]
            self.counter += 1
        return tmp

    def upvar(self, var:str):
        tmp = self.varnums.get(var)
        self.varnums.update({var:self.varnums.get(var)+1})
        return tmp

    def calRange(self, v:QXCRange):
        if isinstance(v.left(), QXNum) and v.left().num() == 0:
            return v.right()
        return QXBin("-", v.right(), v.left())

    def genSizeMap(self):
        self.sizemap = dict()
        for locus, qty, num in self.varnums:
            for elem in locus:
                v = self.calRange(elem.crange())
                self.sizemap.update({(elem.ID(), num):v})


    def genArgs(self, binds):
        for locus, qty, num in self.varnums:
            if isinstance(qty, TyNor):
                for elem in locus:
                    binds += [DXBind(elem.ID(), SeqType(SType("bv1")), num)]
            if isinstance(qty, TyHad):
                for elem in locus:
                    binds += [DXBind(elem.ID(), SeqType(SType("real")), num)]
            if isinstance(qty, TyEn):
                if isinstance(qty.flag(), QXNum):
                    tyv = qty.flag().num()
                    binds += [DXBind("amp", genType(tyv, SType("real")), num)]
                    binds += [DXBind("phase", genType(tyv, SType("real")), num)]
                    for elem in locus:
                        binds += [DXBind(elem.ID(), genType(tyv, SeqType(SType("bv1"))), num)]
                else:
                    return None

        return binds

    def removeLocus(self, n:int):
        vs = []
        for i in range(len(self.varnums)):
            locus,qty,num = self.varnums[i]
            if n == num:
                vs += self.varnums[i+1:len(self.varnums)]
                break
            else:
                vs += [(locus,qty,num)]

        self.varnums = vs


    def replaceType(self, n:int, t:QXQTy):
        vs = []
        for i in range(len(self.varnums)):
            locus,qty,num = self.varnums[i]
            if n == num:
                vs += [(locus,t,num)]+self.varnums[i+1:len(self.varnums)]
                break
            else:
                vs += [(locus,qty,num)]

        self.varnums = vs


    #argument generation 1) for classical variables, just directly gen.
    #2) for quantum variable, do not gen argument in qafny,
    # but take in the loci in requires, and gen variables according to loci with correct types.
    def visitMethod(self, ctx: Programmer.QXMethod):
        self.fvar = str(ctx.ID())
        self.fkenv = self.kenv.get(self.fvar)
        self.ftenvp = self.tenv.get(self.fvar)[0]
        self.ftenvr = self.tenv.get(self.fvar)[1]
        self.varnums = self.genVarNumMap(self.ftenvp)
        self.genSizeMap()

        tmpbind = []
        for bindelem in ctx.bindings():
            tmpv = bindelem.accept(self)
            if tmpv is not None:
                tmpbind.append(tmpv)
        
        tmpbind = self.genArgs(tmpbind)

        if tmpbind is None:
            return None

        tmpcond = []
        for condelem in ctx.conds():
            tmpcond.extend(condelem.accept(self))

        axiom = ctx.axiom()
        tmpstmt = []
        if not axiom:
            for stmtelem in ctx.stmts():
                s = stmtelem.accept(self)
                if isinstance(s, list):
                    tmpstmt.extend(s)
                else:
                    tmpstmt.append(s)

        tmpreturn = []
        for reelem in ctx.returns():
            tmpv = reelem.accept(self)
            if tmpv is not None:
                tmpreturn.append(tmpv)

        return DXMethod(str(self.fvar), axiom, tmpbind, tmpreturn, tmpcond, tmpstmt)


    def visitProgram(self, ctx: Programmer.QXProgram):
        tmp = []
        for elem in ctx.method():
            tmp.append(elem.accept(self))
        return DXProgram(tmp)


    def visitBind(self, ctx: Programmer.QXBind):
        if isinstance(ctx.type(), TySingle):
            ty = ctx.type().accept(self)
            return DXBind(ctx.ID(), ty, None)
        if ctx.ID() and not ctx.type():
            return DXBind(ctx.ID(), None)
        return None


    def visitAssert(self, ctx: Programmer.QXAssert):
        v = ctx.spec().accept(self)
        x = [DXAssert(i) for i in v] if isinstance(v,list) else DXAssert(v)
        return x
        

    def visitRequires(self, ctx: Programmer.QXRequires):
        v = ctx.spec().accept(self)
        x = [DXRequires(i) for i in v]
        return x


    def visitEnsures(self, ctx: Programmer.QXEnsures):
        v = ctx.spec().accept(self)
        x = [DXEnsures(i) for i in v]
        return x


    def visitCRange(self, ctx: Programmer.QXCRange):
        super().visitCRange(ctx)


    def visitCast(self, ctx: Programmer.QXCast):
        v = subLocus(ctx.locus(), self.varnums)
        if v is not None:
            loc,qty,num = v
            vs = compareLocus(ctx.locus(), loc)
            if not vs and isinstance(qty, TyHad) and isinstance(ctx.qty(), TyEn):
                result = [DXAssign(makeVars(ctx.locus(),ctx.qty(),self.counter),DXCall("hadEn", makeVars(ctx.locus(),TyHad(),num)))]
                self.removeLocus(num)
                self.varnums = [(loc,ctx.qty(),self.counter)] + self.varnums
                self.counter += 1
                return result
        else:
            v = subLocusGen(ctx.locus(),self.varnums)
            if v is not None:
                (floc, ty, rev, num) = v
                vs = compareLocus(ctx.locus(), floc)
                if not vs and isinstance(ty, TyHad) and isinstance(ctx.qty(), TyEn):
                    result = [DXAssign(makeVars(ctx.locus(), ctx.qty(), self.counter),
                                       DXCall("hadEn", makeVars(ctx.locus(), TyHad(), num)))]
                    self.removeLocus(num)
                    self.varnums = [(floc, ty, self.counter)] + self.varnums
                    self.counter += 1
                    return result



    def visitInit(self, ctx: Programmer.QXInit):
        return DXInit(ctx.binding().accept(self))


    #substitution
    #subst = SubstAExp(id, DXBind)
    #subst.visit(AEXp)

    def genPreds(self, locus: [QXQRange], t:QXQTy, num: int, ids : [str], kets:[QXKet], phase: QXAExp):
        vars = makeVars(locus, t, num)
        pVar = vars[1]
        kVars = vars[2:]
        tmpSubs = []
        for i in range(len(ids)):
            subst = SubstDAExp(ids[i], kVars[i])
            tmpSubs += [subst]
        newVars = makeVars(locus, t, self.counter)
        newPVar = newVars[1]
        newKVars = newVars[2:]
        self.counter += 1

        res = []
        for ket in kets:
            re = ket.accept(self)
            for esub in tmpSubs:
                re = esub.visit(re)
            res += [re]

        preds = []
        for i in range(len(newKVars)):
            preds += [DXComp("==", newKVars[i], res[i])]

        newp = phase.accept(self)
        for esub in tmpSubs:
            newp = esub.visit(newp)

        preds += [DXComp("==", newPVar, DXBin("*", pVar, newp)),DXComp("==", vars[0], newVars[0])]
        return preds

    def dealExps(self, locus: [QXQRange], pexp:DXAExp, lexp:[DXAExp], exps: [QXStmt]):
        for elem in exps:
            if isinstance(elem, QXQAssign) and isinstance(elem.exp(), QXOracle):
                loc = elem.locus()
                ids = elem.exp().ids()
                kets = elem.exp().vectors()
                phase = elem.exp().phase()

                tmpSubs = []
                for i in range(len(ids)):
                    tarExp = locateAExp(locus, loc[i], lexp)
                    if tarExp is None:
                        return None
                    subst = SubstDAExp(ids[i], tarExp)
                    tmpSubs += [subst]

                res = []
                for ket in kets:
                    re = ket.accept(self)
                    for esub in tmpSubs:
                        re = esub.visit(re)
                    res += [re]

                for i in range(len(loc)):
                    lexp = replaceAExp(locus, loc[i], lexp, res[i])

                newp = phase.accept(self)
                for esub in tmpSubs:
                    newp = esub.visit(newp)

                return DXBin("*", pexp, newp), lexp



    def genKetList(self, varmap: dict, flag: int, num:int, ids: [str], kets: [QXKet]):
        tmp = []
        for i in range(len(ids)):
            if isinstance(kets[i].vector(), QXBind) and ids[i] == kets[i].vector().ID():
                var = varmap.get(ids[i]).ID()
                tmp += [DXAssign([DXBind(var,genType(flag,SeqType(SType("bv1"))),self.counter)],
                                 DXBind(var,genType(flag,SeqType(SType("bv1"))),num))]
            elif isinstance(kets[i].vector(), QXBin):
                var = varmap.get(kets[i].vector().left().ID())
                val = DXNum(kets[i].vector().right().num())
                tmp += [DXAssign([DXBind(var,genType(flag,SeqType(SType("bv1"))),self.counter)],
                                 DXCall("lambdaBaseEn",[val,DXBind(var,genType(flag,SeqType(SType("bv1"))),num)]))]
        return tmp


    def visitQAssign(self, ctx: Programmer.QXQAssign):
        v = subLocus(ctx.locus(), self.varnums)
        if v is not None:
            loc,qty,num = v

            if isinstance(qty, TyNor) and isinstance(ctx.exp(),QXSingle) and ctx.exp().op() == "H":
                vs = compareLocus(ctx.locus(), loc)
                if not vs:
                    self.replaceType(num,TyHad())
                else:
                    self.removeLocus(num)
                    self.varnums = [(ctx.locus(),TyHad,self.counter),(vs,TyNor(),num)] + self.varnums
                    self.counter += 1
                return [DXAssign(makeVars(ctx.locus(),TyNor(),self.counter),DXCall("hadNorHad", makeVars(ctx.locus(),TyNor(),num)))]

            if isinstance(qty, TyEn) and isinstance(ctx.exp(),QXSingle) and ctx.exp().op() == "H":
                flagNum = qty.flag().num()
                vs = compareLocus(ctx.locus(), loc)
                self.replaceType(num, TyEn(QXNum(flagNum + 1)))

                tmr = []
                for rem in vs:
                    tmr += [DXAssign(makeVars([rem], TyEn(QXNum(flagNum + 1)), self.counter),
                                     DXCall("castBaseEn", makeVars([rem], qty, num)))]
                result = tmr + [DXAssign(makeVars(ctx.locus(),TyEn(QXNum(flagNum + 1)),self.counter),
                                         DXCall("hadEn", makeVars(ctx.locus(),qty,num)))]
                self.removeLocus(num)
                self.varnums = [(loc,TyEn(QXNum(flagNum + 1)),self.counter)] + self.varnums
                self.counter += 1
                return result

            if isinstance(qty, TyEn) and isinstance(ctx.exp(),QXOracle):
                flagNum = qty.flag().num()
                varmap = makeMap(ctx.exp().ids(), ctx.locus())
                result = self.genKetList(varmap, flagNum, num, ctx.exp().ids(), ctx.exp().vectors)
                vs = compareLocus(ctx.locus(), loc)
                for rem in vs:
                    result += [DXAssign([DXBind(rem.ID(),genType(flagNum,SeqType(SType("bv1"))),self.counter)],
                                        DXBind(rem.ID(),genType(flagNum,SeqType(SType("bv1"))),num))]
                self.removeLocus(num)
                self.varnums = [(loc,qty,self.counter)] + self.varnums
                self.counter += 1
                return result

        return None


    def visitMeasure(self, ctx: Programmer.QXMeasure):
        return super().visitMeasure(ctx)

    def visitCAssign(self, ctx: Programmer.QXCAssign):
        return DXAssign([DXVar(ctx.ID())], ctx.aexp().accept(self))



    def visitIf(self, ctx: Programmer.QXIf):
        if isinstance(ctx.bexp(), QXBool):
            bex = ctx.bexp().accept(self)
            terms = []
            for elem in ctx.stmts():
                terms += elem.accept(self)
            typeCheck = TypeChecker(self.fkenv, self.varnums, self.counter)
            typeCheck.visit(ctx)
            self.fkenv = typeCheck.kenv()
            self.varnums = typeCheck.tenv()
            self.counter = typeCheck.counter

            return DXIf(bex, terms, [])

        #the below one is an example for en(1) typed only
        #we might need to deal with other cases like aa type, and had type
        lcollect = LocusCollector()
        lcollect.visit(ctx.bexp())
        for elem in ctx.stmts():
            lcollect.visit(elem)
        newLoc = lcollect.renv

        result = []
        vs = subLocus(newLoc, self.varnums)
        if vs is None:
            v = subLocusGen(newLoc, self.varnums)
            if v is None:
                return None
            floc, ty, rev, num = v
            rea = QXCast(TyEn(QXNum(1)), floc)
            result += [rea.accept(self)]
            self.varnums = [(floc, ty, self.counter)] + rev
            self.counter += 1
            vs = floc,ty, num

        nLoc, nTy, nNum = vs
        exps = makeVars(nLoc,nTy, nNum)
        vk = DXBind("nvar", SType("nat"), self.counter)
        self.counter+=1
        exps = updateInd(exps, vk)

        re = self.dealExps(nLoc, exps[1], exps[2:], ctx.stmts())

        if re is not None:
            pre, kre = re
        else:
            return None

        #need to add a sub function to store the transitions of predicates
        #need to insert pred to each of the predicates.
        #if we find the subterm has a predicate like requires P, ensures Q
        #then we need to say two things in the following:
        #We first say the inputting the predicate is P, then for Q, we will have
        # for all i, index(locus) <= i < index_end(locus) ==> pred(i) ==> Q(i)
        # forall i, index(locus) <= i < index_end(locus) ==> not pred(i) ==> P(i)
        # this means that in an array, if pred(i) is good, then Q(i), else P(i)
        # we also need to create a heap to store DXMethod
        # when genearting a method, it cannot be inside a stmt
        #tyCheck = TypeChecker(self.fkenv, self.ftenvp, self.fvar,self.ind)
        #tyCheck.visit()

        genExps = exps[0]+[pre]+kre

        newExps = makeVars(nLoc, nTy, self.counter)
        self.counter += 1
        newExps = updateInd(newExps, vk)

        vx = DXBind("nvar", SType("nat"), self.counter)
        self.counter += 1

        #genereating the invs, we might need to add more to make Dafny happy
        tmpInv = []
        for elem in newExps:
            tmpInv += [DXLogic("&&", DXComp("<=", DXNum(0),vx),DXComp("<=",vx,DXUni("len",elem.bind())))]

        for i in range(len(genExps)):
            tmpInv += [DXAll(vk, DXLogic("==>",
                DXLogic("&&", DXComp("<=", DXNum(0),vk),DXComp("<=",vk,vx)),
                    DXComp("==", newExps[i],genExps[i])))]


        pred, v = ctx.bexp().accept(self)
        terms = []
        for elem in ctx.stmts():
            terms += elem.accept(self)

        wil = DXWhile(DXComp("<",vx, DXNum(100)), [DXIf(pred, [DXAssign([v], DXNum(1))]+ terms,[])],tmpInv)
        result += [DXInit(vx, DXNum(0)), wil]
        return result

    def visitFor(self, ctx: Programmer.QXFor):
        x = ctx.ID()
        tmpinvs = []
        for inv in ctx.inv():
            tmpinvs += [inv.accept(self)]

        tmpstmts = []
        for elem in ctx.stmts():
            tmpstmts += elem.accept(self)

        lbound = ctx.crange().left().accept(self)
        rbound = ctx.crange().right().accept(self)
        vx = DXBind(x, SType("nat"))

        return [DXInit(vx, lbound), DXWhile(DXComp("<", vx, rbound), tmpstmts, tmpinvs)]


    def visitCall(self, ctx: Programmer.QXCall):
        return super().visitCall(ctx)

    def visitSingleT(self, ctx: Programmer.TySingle):
        return SType(ctx.type())

    def visitArrayT(self, ctx: Programmer.TyArray):
        ty = ctx.type().accept(self)
        return SeqType(ty)

    def visitFun(self, ctx: Programmer.TyFun):
        super().visitFun(ctx)

    def visitQ(self, ctx: Programmer.TyQ):
        return ctx.flag().accept(self)

    def visitCNot(self, ctx: Programmer.QXCNot):
        v = ctx.next().accept(self)
        return DXNot(v)

    def visitNor(self, ctx: Programmer.TyNor):
        return super().visitNor(ctx)

    def visitTyHad(self, ctx: Programmer.TyHad):
        return super().visitTyHad(ctx)

    def visitEn(self, ctx: Programmer.TyEn):
        super().visitEn(ctx)

    def visitQSpec(self, ctx: Programmer.QXQSpec):
        loc,qty,num = subLocus(ctx.locus(), self.varnums)
        self.qvars = makeVars(ctx.locus(), ctx.qty(), num)
        self.locus = ctx.locus()
        return ctx.state().accept(self)


    def visitAA(self, ctx: Programmer.TyAA):
        return super().visitAA(ctx)

    def visitSKet(self, ctx: Programmer.QXSKet):
        return ctx.vector().accept(self)

    def visitVKet(self, ctx: Programmer.QXVKet):
        return ctx.vector().accept(self)

    def visitTensor(self, ctx: Programmer.QXTensor):
        if ctx.ID() is None:
            x = DXBind("tmp", SType("nat"), self.counter)
            self.counter += 1
        else:
            x = DXBind(str(ctx.ID()))

        tmp = []

        for i in range(len(self.locus)):
            left = self.locus[i].crange().left().accept(self)
            right = self.locus[i].crange().right().accept(self)
            v = ctx.kets()[i].accept(self)
            tmp += [DXAll(x, DXLogic("==>", DXInRange(x, left, right), DXComp("==", DXIndex(self.qvars[i], x), v)))]

        return tmp


    def visitSum(self, ctx: Programmer.QXSum):
        tmp = []

        for i in range(len(self.qvars)):
            v = ctx.kets()[i].accept(self)
            eq = DXComp("==",makeIndex(self.qvars[i], ctx.sums()),v)
            for con in ctx.sums():
                x = DXBind(con.ID(), SType("nat"))
                arange = DXInRange(x,con.crange().left().accept(self), con.crange().right().accept(self))
                eq = DXAll(x, DXLogic("==>",arange,eq))
            tmp += [eq]

        num = self.qvars[0].num()
        ampvar = makeIndex(DXBind("amp", SType("real"), num),ctx.sums())
        v = ctx.amp().accept(self)
        eq = DXComp("==", ampvar, v)
        for con in ctx.sums():
            x = DXBind(con.ID(), SType("nat"))
            arange = DXInRange(x, con.crange().left().accept(self), con.crange().right().accept(self))
            eq = DXAll(x, DXLogic("==>", arange, eq))
        return ([eq]+tmp)

    def visitLogic(self, ctx: Programmer.QXLogic):
        left = ctx.left().accept(self)
        right = ctx.right().accept(self)
        return DXLogic(ctx.op(), left, right)


    def visitBool(self, ctx: Programmer.QXComp):
        left = ctx.left().accept(self)
        right = ctx.right().accept(self)
        return DXComp(ctx.op(), left, right)


    def visitQIndex(self, ctx: Programmer.QXQIndex):
        return (None, DXIndex(DXBind(ctx.ID()),ctx.index().accept(self)))


    def visitCon(self, ctx: Programmer.QXCon):
        return super().visitCon(ctx)


    def visitQComp(self, ctx: Programmer.QXQComp):
        return (DXComp(ctx.op(), ctx.left().accept(self), ctx.right().accept(self)),
                DXIndex(DXBind(ctx.index().ID()),ctx.index().accept(self)))

    def visitQNot(self, ctx: Programmer.QXQNot):
        pred, index = ctx.next().accept(self)
        return (DXNot(pred), index)

    def visitAll(self, ctx: Programmer.QXAll):
        x = ctx.bind().accept(self)
        p = ctx.next().accept(self)
        return DXAll(x, p)

    def visitBin(self, ctx: Programmer.QXBin):
        return DXBin(ctx.op(), ctx.left().accept(self), ctx.right().accept(self))

    def visitUni(self, ctx: Programmer.QXUni):
        return DXUni(ctx.op(), ctx.next().accept(self))

    def visitSingle(self, ctx: Programmer.QXSingle):
        return super().visitSingle(ctx)

    def visitOracle(self, ctx: Programmer.QXOracle):
        super().visitOracle(ctx)

    def visitNum(self, ctx: Programmer.QXNum):
        return DXNum(ctx.num())

    def visitHad(self, ctx: Programmer.QXHad):
        if ctx.state() == "+":
            return DXCall("omega", [DXNum(0), DXNum(2)])
        else:
            return DXCall("omega", [DXNum(1), DXNum(2)])

    def visitQRange(self, ctx: Programmer.QXQRange):
        return super().visitQRange(ctx)
    
    def visitVarState(self, ctx):
        pass