// --------------------------- LOGIC GATES -------------------------------------


// Works
method HadamardZero(q : Q[1]) returns (q : Q[1])
  requires {q[0] : nor ↦ |0⟩}
  ensures {q[0] : had ↦ |+⟩}
{
  q[0] *= H;
}

// Doesn't compile
method HadamardGeneral(q : Q[1], a : real, b : real) returns (q : Q[1])
  requires {q[0] : had ↦ a|0⟩ + b|1⟩}
  ensures {q[0] : had ↦ (a+b)/sqrt(2)|0⟩ + (a-b)/sqrt(2)|1⟩}
{
  q[0] *= H;
}

// Doesn't Compile
method HadamardArray(q : Q[n]) returns (q : Q[n])
  requires {q[0,n) : nor ↦ ⊗ i ∈ [0,n) . |0⟩}
  ensures {q[0,n) : had ↦ ⊗ i ∈ [0,n) . |+⟩}
{
  for i in [0, k)
  {
    q[i] *= H;
  }
}

// Compiles, doesn't verify, since "castBVInt(q6)" generates instead of "castBVInt(q7)"
method PauliX(q : Q[1]) returns (q : Q[1])
  requires {q[0] : nor ↦ |0⟩}
  ensures {q[0] : nor ↦ |1⟩}
{
  q[0] *= λ (x => |(x + 1) % 2⟩);   // Not general - only works for nor types.
}

// ??
method PauliXGeneral(q : Q[1], x : nat) returns (q : Q[1])
  requires {q[0] : nor ↦ |x⟩}
  ensures {q[0] : had ↦ i|1⟩}
{
  // Want: a|0> + b|1> maps to a|1> + b|0>.
  // Is this possible?
}

// Works
method PhaseShift(q : Q[1], k : nat, x : real, y : real) returns (q : Q[1])
  requires {q[0] : nor ↦ |k⟩}
  ensures {q[0] : nor ↦ ω(x, y)|k⟩}
{
  q[0] *= λ (x => ω(x, y)|x⟩);
}



// ---------------------- STATE CONSTRUCTION -----------------------------------


// Doesn't compile
method BellPair(q : Q[2]) returns (q : Q[2])
  requires {q[0,2) : nor ↦ |00⟩}
  ensures {q[0,2) : en ↦ 1/sqrt(2) (|00⟩) + 1/sqrt(2) (|11⟩)}

  // These versions of the above line don't work:
  // ensures {q[0,2) : en ↦ 1/sqrt(2) ∑ k ∈ [0, 2) . |kk⟩}
  // ensures {q[0,2) : en ↦ 1/sqrt(2) (|00⟩ + |11⟩)}
  // It appears Qafny doesn't like statements with magnitudes factored out

{
  q[0] *= H;
  if (q[0]) { q[1] *= λ (x => |(x + 1) % 2⟩); }
}


// Doesn't compile
method GHZGeneral(q : Q[n]) returns (q : Q[n])
  requires {q[0,n) : nor ↦ ⊗ i ∈ [0,n) . |0⟩}
  ensures {q[0,n) : en ↦ ∑ k ∈ [0, 2) . 1/sqrt(2) (⊗ i ∈ [0,n) . |k⟩)}
{
  q[0] *= H;
  for i in [0, n) {
    if (q[0]) {
      q[i] *= λ (x => |(x + 1) % 2⟩);
    }
  }
}



// ------------------------- REVERSIBILITY -------------------------------------

// Doesn't compile
method DoubleH(q : Q[1]) returns (q : Q[1])
  requires {q[0] : nor ↦ |0⟩}
  ensures {q[0] : nor ↦ |0⟩}
{
  q[0] *= H;
  q[0] *= H;
}

// Doesn't compile
method QFTInvertability(q : Q[n]) returns (q : Q[n])
  requires {q[0,n) : nor ↦ |0⟩}
  ensures {q[0,n) : nor ↦ ⊗ i ∈ [0,n) . |0⟩}
{
  q[0,n) *= QFT;
  q[0,n) *= RQFT;
}



// -------------------- QUANTUM FOURIER TRANSFORM ------------------------------

// Apply one, check if it's as described in the paper






// Notes:
// - Omega(x,y) is the xth root of unity for root y, ie, omega(x,y)=exp(2πix/y)
