//The Linear Combination of Uniteries algorithm proof in Qafny

method {:axiom} uf(q: Q[n], n:nat)

method {:axiom} vf(q: Q[n], n:nat)

function {:axiom} add(uf : Q[n] -> nat -> Q[n], vf : Q[n] -> nat -> Q[n]) //need to define a sum function of two functions, which will be an array map of sum function

method LCU(q : Q[n], p : Q[1], n : nat) returns { sa: nat}
              //do we really want nat -> nat or bitvector, like seq<bv1> ? we can have bitvectors in our system
  requires n >= 1
  requires { p[0] : nor ↦ |0⟩  }
  ensures { sa == 0 ==> q[0,n) == add(uf,vf)(old(q[0,n)), n) }
{
  p[0] *= H;
  if (p[0]) { uf(q,n); }
  if (not p[0]) { vf(q,n); }
  
  assert {p[0],q[0,n) : en ↦ 1/sqrt(2) (|0⟩ (uf(q[0,n),n)) + |1⟩ (vf(q[0,n),n))) }
  
  p[0] *= H;
  assert {p[0],q[0,n) : en ↦ 1/2 (|0⟩ (uf(q[0,n),n) + vf(q[0,n),n)) + |1⟩ (uf(q[0,n),n) - vf(q[0,n),n))) }

  sa, prob := measure (p[0]); //once p[0] is measured, the result will push add(uf,vf) to be applied on q[0,n)
}

