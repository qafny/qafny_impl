//This is the QPE algorithm file. 
//the source is in https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm
method {:axiom} U(n:nat, q: Q[n], a:nat)
  requires { q[0 , n) : en ↦ v ⊗ phi }
  ensures { q[0 , n) : en ↦ v * omega(a, 2^n) ⊗ phi }
  

method repeat(n:nat, q:Q[n], a:nat, m:nat)
  requires { q[0 , n) : en ↦ ⊗ phi }
  ensures { q[0 , n) : en ↦ omega(m * a, 2^n) ⊗ phi }
{

  for k in [0, m)
  invariant { q[0 , n) : en ↦ omega(k * a, 2^n) ⊗ phi }
  {
     U(n,q,a);
  }
}
  
  
method QPE(q : Q[n], p : Q[n], n:nat, U : Q[n] -> Q[n], psi: Q[n], lambda : nat) returns (y:nat, p : real)
  requires { q[0 , n) : nor ↦ |0⟩ }
  requires { p[0 , n) : en ↦ ⊗ phi } 
  ensures y  == lambda * 2^n ==> p == 4 / PI^2
{
  q[0, n) *= H;
  
  for k in [0, n)
    invariant {
      q[0, k), p[0, n) : en ↦ ∑ j ∈ [0, 2^k)) . 1 / sqrt(2^k) . ω (j * lambda, 1)  . | j ⟩ ⊗ psi
    }
    invariant {
      q [k , n) : had ↦ |+⟩
    }
  {
    repeat(n,p, lambda, 2^k);
  }

  q[0,n) *= RQFT;

  assert { q[0,n) : en ↦  ∑ j ∈ [0, 2^n)) . 1 / sqrt(2^n) * 1 / sqrt(2^n) . (∑ v ∈ [0, 2^n) . ω (j * lambda, 1) * ω (- j * v, 2^n)  . | v ⟩ ) };
  assert { q[0,n) : en ↦  ∑ v ∈ [0, 2^n)) . 1 / (2^n) . (∑ j ∈ [0, 2^n) . ω (j * lambda * 2^n - j * v, 2/n) )  . | v ⟩ };

  y,p *= measure(q);
}  

