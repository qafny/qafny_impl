// Non-Boolean Amp
// https://arxiv.org/abs/2102.04975

method {:axiom} sf(n:nat, p: Q[1], q: Q[n], phi: Q[n])
  requires { phi == ∑ k ∈ [0, 2) . ∑ j ∈ [0, 2^n) . 1/sqrt(2) * a(j) | k ⟩ | j ⟩ }
  requires { p[0], q[0 , n) : en(2) ↦ ⊗ phi }
  ensures { p[0], q[0 , n) : en(2) ↦ ⊗ phi }
  
method {:axiom} U(n:nat, q: Q[n], f : nat -> real)
  requires { q[0 , n) : nor ↦ | j ⟩ }
  ensures { q[0 , n) : nor ↦ omega(f(j), 2^n) | j ⟩ }

method NonBoolean(q : Q[n], p: Q[1], n: nat, m: nat, f: nat -> real) returns (y: nat, prob: real)
    requires { p[0] : nor ↦ |0⟩ }
    requires { q[0,n): en(1) ↦ ∑ k ∈ [0, 2) . ∑ j ∈ [0, 2^n) . 1 / sqrt(2) * a | k ⟩ | j ⟩ }
{ 
    
    for j in [0, m)
    {
      Diff(n,q,f,(2 * i + 1) * sqrt(sumFun(f,2^n) / 2^n),sqrt(sumFun(f,2^n) / 2^n));
      if (j % 2 == 0)
      {
        if (p[0]) { uf(q, n); }
      }
      else {
        if (not p[0]) { uf^{-1}(q,n); }
      }
    }
    
    y, prob := meas(p[0]);
}
