// Non-Boolean Amp
// https://arxiv.org/abs/2102.04975

method {:axiom} uf(q: Q[n], f: nat -> real, n:nat)
    requires { q[0, n) : nor ↦ | k ⟩ }
    ensures { q[0, n) : nor ↦ omega(f(k), 2^n) | k ⟩ }
    
    
/*function {:axiom} inverse(uf : Q[n] -> nat -> Q[n]) //inverse function is always existed, so add to language op set.
 *                                                    //the current implementation plan is to make the inverse function as built-in as ^{-1}
 */

method NonBoolean(q : Q[n], p: Q[1], n: nat, m: nat, f: nat -> real) returns (y: nat, prob: real)
    requires { p[0] : nor ↦ |0⟩ }
    requires { q[0,n): en(1) ↦ ∑ k ∈ [0, 2) . ∑ j ∈ [0, 2^n) . 1 / sqrt(2) * a | k ⟩ | j ⟩ }
{   
    p[0] *= H;
    
    for j in [0, m)
    {
      Diff(n,q,f,(2 * i + 1) * sqrt(sumFun(f,2^n) / 2^n),sqrt(sumFun(f,2^n) / 2^n));
      if (j % 2 == 0)
      {
        if (p[0]) { uf(q, n); }
      }
      else {
        if (not p[0]) { uf^{-1}(q,n); }
      }
    }
    
    y, prob := meas(p[0]);
}
